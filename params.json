{"name":"node-wordnet-magic","tagline":"tools for working with Princeton's lexical database WordNet","body":"node-wordnet-magic\r\n==================\r\n\r\nA node.js module for working with Princeton's WordNet lexical database for the English language.\r\n\r\n[![NPM version](https://badge.fury.io/js/wordnet-magic.svg)](http://badge.fury.io/js/wordnet-magic)\r\n\r\n# Getting Started\r\n\r\n## What is it about?\r\n\r\nSince natural language processing (NLP) has to deal with a lot of non-digital features (comprising ambivalence, dubiety of language, not to mention irony, lies or rethorical tricks and ruses) it always has been a great challenge, confronting the programmer with a constant need of sense disambiguation. \r\n\r\nThe WordNet project of Princeton University, developed for more than 20 years, has been designed for the needs of computer linguistics and has proven to be a very valuabe resource in many of the hardest NLP tasks.\r\n\r\nThe objective of this package is to make this richness available to the node eco-system. There are quite a few wordnet packages already, providing some nice features, but there is none that tries to reflect the complete WordNet architecture (centered around synsets). This is what the wordnet-magic module is aiming for.\r\n\r\nCurrently, the module offers the following features:\r\n\r\n## Features\r\n\r\n- word type detection\r\n- abilitiy to retrieve hypernyms, synonyms, homonyms, meronyms etc. for a given synset \r\n- asynchronuos module supporting both classical node.js callbacks and promises implemented via Bluebird\r\n- implements WordNet's Morphy to find base words of inflected forms\r\n\r\n## Installation & Setup\r\n\r\nThe module is available through npm via\r\n\r\n```\r\nnpm install wordnet-magic\r\n``` \r\n\r\nInside node, the package can then be loaded as any other module:\r\n\r\n``` \r\nvar wn = require('wordnet-magic');\r\n``` \r\n\r\nHowever, the WordNet database has to be downloaded seperately and placed into the /data folder of the package directory. The package expects WordNet in SQLite format, which can be obtained from the URL \r\n[http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/](http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/). If for whatever reason you decide to place\r\nthe database file in another location, you have to tell the module as follows before using any of the other functions:\r\n\r\n``` \r\nwn.registerDatabase(<insert path here>);\r\n``` \r\n\r\n## Example Code\r\n\r\nExample code for most of the functions is distributed in the *examples* subdirectory of the package repository.\r\n\r\n# API\r\n\r\n## Callbacks and Promises \r\n\r\nDue to the asynchronous nature of JavaScript's I/O operations, all functions in the module are asynchronous by nature. Hence, following conventional design, a callback function has to be passed to the function as the last argument. This callback function  has two parameters: an error object which is *null* if no error is thrown and a second parameter which is the returned value from the invoked function. \r\n\r\nAlternatively, the wordnet-magic package implements promises via the [Bluebird](https://github.com/petkaantonov/bluebird) package. In this documentation, we stick to the callback style as it is more conventional, although one might argue that using promises results in clear code. \r\n\r\nThe following example demonstrates the use of both callbacks and promises when using the wordnet-magic module:\r\n\r\n```\r\nwn.isNoun(\"callback\", function(err, data){ console.log(data)});\r\nwn.isNoun(\"promise\").then(console.log);\r\n```\r\n\r\n## Word\r\n\r\nThe package includes a word class which is a simple wrapper for any user-supplied string \r\nproviding methods for accessing information provided by WordNet about the word. A word is created as follows:\r\n\r\n```\r\nvar word = new wn.Word(\"cat\");\r\n```\r\n\r\nThe constructor accepts as a second argument a part-of-speech type. Hence, if supplied, *pos* must be \r\neither *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective.\r\n\r\nInvoking the constructor function returns a new object with the following properties and methods:\r\n\r\n### Properties\r\n\r\n#### .lemma\r\n\r\nThis key holds the user-supplied word passed to the constructor function at creation of the object. \r\n\r\n#### .pos (optional)\r\n\r\nIf the word was created by passing the constructor function a part-of-speech type, this key will hold the supplied value. Otherwise it is *undefined*.\r\n\r\n### Methods\r\n\r\n#### .getSynsets(callback)\r\n\r\nQueries WordNet for an array of Synset objects matching the word and passes them to the callback function. If the part-of-speech\r\ntype exists for word owning the method, the search is restricted to only return synsets of said type. \r\n\r\nExample:\r\n```\r\nvar kiss = new wordNet.Word(\"kiss\",\"v\");\r\nkiss.getSynsets(function(err, data){\r\n\tconsole.log(util.inspect(data, null, 3));\r\n});\r\n``` \r\n\r\nOutput:\r\n```\r\n[ { synsetid: 201433863,\r\n    words: \r\n     [ { lemma: 'buss' },\r\n       { lemma: 'kiss' },\r\n       { lemma: 'osculate' },\r\n       { lemma: 'snog' } ],\r\n    definition: 'touch with the lips or press the lips (against \r\n    someone\\'s mouth or other body part) \r\n    as an expression of love, greeting, etc.',\r\n    pos: 'v',\r\n    lexdomain: 'verb.contact' },\r\n  { synsetid: 201434356,\r\n    words: [ { lemma: 'kiss' } ],\r\n    definition: 'touch lightly or gently',\r\n    pos: 'v',\r\n    lexdomain: 'verb.contact' } ]\r\n```\r\n\r\n#### .getAntonyms(callback)\r\n\r\nRetrieves an array of objects containing the antonyms (= words opposite in meaning, e.g. black and white) for \r\nthe supplied word and passes it to the supplied callback function. The objects have three keys, the orginal *lemma*, the \r\n*synset* for which the antonym relationship exists and the *antonym* itself. \r\n\r\nExample:\r\n```\r\nvar high = new wn.Word(\"high\");\r\nhigh.getAntonyms(function(err, antonymArray){\r\n\tconsole.log(antonymArray);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: 'greater than normal in degree or intensity or amount' },\r\n  { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: '(literal meaning) being at or having a relatively great or \r\n    specific elevation or upward extension\r\n     (sometimes used in combinations like knee-high\\')' },\r\n  { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: 'used of sounds and voices; high in pitch or frequency' } ]\r\n```\r\n\r\n#### .getPolysemyCount(pos, callback)\r\n\r\nReturns the polysemy count (also called familiarity) for the word. This denotes the number of different senses the word has in the supplied word type category. \r\n\r\nExample:\r\n\r\n```\r\nvar kiss = new wordNet.Word(\"kiss\",\"v\");\r\nkiss.getPolysemyCount(\"v\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput: \r\n\r\n```\r\n2\r\n```\r\n\r\n## Morphy\r\nThe package implements Morphy, a set of rules part of WordNet which try to determine the base form of a given inflected form. This\r\nfunctionality is important insofar as words are stored only in their base form in the data base, and not taking this into account will likely\r\nproduce bad results. A detailed explanation of the steps Morphy takes to determine the base form can be found in the original documentation:\r\n[https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html](https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html)\r\n\r\n#### wn.morphy(word, pos, callback)\r\nReturns the base form for an inflected word to the callback function. As a second argument, the function takes a character denoting the part of speech,\r\nwhich can take one of the values *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective. Internally,\r\nthe function performs different steps depending on the type of the word. If *pos* is not supplied, all five possibilities are checked and the results\r\naggregated. \r\n\r\nThen the function returns an array of object(s) with two properties, *lemma* and *part_of_speech*. These are themselves instances of the basic Word class, \r\nextended by having the word type as an extra key. \r\nThe first is the matching base word itself and the second its word type. \r\n\r\nExample:\r\n```\r\nwn.morphy(\"loci\", \"n\" , function(err, data){\r\n\tconsole.log(data);\r\n})\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'locus', part_of_speech: 'n' } ]\r\n```\r\n\r\n## Word type checking\r\n\r\nThe module provides several functions for checking whether a given word belongs to a certain word type. All these functions\r\ntake as their first argument the word in question and as their second argument a callback function. Internally, the functions\r\nfirst use *morphy* to find the base form of the supplied word and then check whether the returned array of objects from *morphy*\r\ncontains an entry of the word type in question.\r\n\r\n#### wn.isNoun(word, callback)\r\n\r\nReturns *true* if *word* is a noun, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isNoun(\"happy\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\nfalse\r\n```\r\n\r\n#### wn.isVerb(word, callback)\r\n\r\nReturns *true* if *word* is a verb, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isVerb(\"kill\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n#### wn.isAdjective(word, callback)\r\n\r\nReturns *true* if *word* is a adjective, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isAdjective(\"filthy\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n#### wn.isAdverb(word, callback)\r\n\r\nReturns *true* if *word* is a adverb, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isAdverb(\"helpfully\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n## Synset\r\n\r\nIn WordNet, a synset is a unique concept which may have many words attached to it. These *synonyms* then share the common \r\nmeaning of the synset. WordNet separates the individual words from the synsets as the former can belong to many different \r\nsynsets: for example, the word *bank* can refer both to the financial institution and a river bank. \r\n\r\nThe most common method to create synsets in the wordnet-magic module is to invoke the .getSynsets() method of a Word object. However,\r\neach synset can also be identified by a *string*  consisting of three parts separated by dots such as \"king.n.1\", where\r\nthe first part denotes a word associated with the synset, the second its word type and the third an incrementing integer for each sense (embodied in the synset) \r\nof the word. In this case, the function fetchSynset(*string*) can be used to retrieve the synset information.\r\n\r\nExample: \r\n\r\n```\r\nwn.fetchSynset(\"dog.n.1\", function(err, synset){\r\n console.log(synset);\t\r\n});\r\n``` \r\n\r\nOutput:\r\n``` \r\n{ synsetid: 102086723,\r\n  words: \r\n   [ { lemma: 'canis familiaris' },\r\n     { lemma: 'dog' },\r\n     { lemma: 'domestic dog' } ],\r\n  definition: 'a member of the genus Canis (probably descended from the common wolf) \r\n  that has been domesticated by man since prehistoric times; occurs in many breeds',\r\n  pos: 'n',\r\n  lexdomain: 'noun.animal' }\r\n``` \r\n\r\n### Properties\r\n\r\nAs we can see from above output, an object of the Synset class has the following properties:\r\n\r\n#### .synsetid\r\n\r\n*For internal use*. Integer which acts as a unique identifier of the synset. \r\n\r\n#### .words\r\n\r\nNot filled upon creation of a synset, this is a placeholder which can hold all the words associated with the synset in question.\r\n\r\n#### .definition\r\n\r\nA string holding the definition of the synset.\r\n\r\n#### .pos\r\n\r\nThe part of speech of the word, taking one of the values *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective.  \r\n\r\n#### .lexdomain\r\n\r\nThe lexical domain of the synset. Each domain category is composed of the word type followed by a \r\ndot and then the category name. WordNet has implemented the following domain categories:\r\n\r\n- adj: all, pert, ppl\r\n- adv: all\r\n- noun: tops, act, animal, artifact, attribute, body, cognition, communication\r\nevent, feeling, food, group, location, motive, object, person\r\nphenomenon, plant, possession, process, quantity, linkdef, shape, state\r\nsubstance, time\r\n- verb: body, change, cognition, communication, competition, consumption, contact, \r\ncreation, emotion, motion, perception, possession, social, stative, weather\r\n\r\n### Methods\r\n\r\nA synset object is equipped with the following methods:\r\n\r\n#### .getDomains(callback)\r\n\r\nRetrieves the domain the synset belongs to. There are three different types of domain, topic, region and usage, which \r\ndifferentiate between topical, geographical and functional relations. The returned array consists of Synsets which have been augmented with this information: they hold an extra property called \"domain_type\" which indicates which of the three domain types applies.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"war.n.1\").then(function(synset){\r\n\tconsole.log(synset)\r\n\tsynset.getDomains().then(function(domain){\r\n\t\tconsole.log(util.inspect(domain, null, 3))\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 108215965,\r\n    words: \r\n     [ { lemma: 'armed forces' },\r\n       { lemma: 'armed services' },\r\n       { lemma: 'military' },\r\n       { lemma: 'military machine' },\r\n       { lemma: 'war machine' } ],\r\n    definition: 'the military forces of a nation',\r\n    pos: 'n',\r\n    lexdomain: 'noun.group',\r\n    domain_type: 'topic' } ]\r\n```\r\n\r\n#### .getDomainTerms(callback)\r\n\r\nRetrieves all the terms for which the current synset functions as a domain. Again, there are the different types of domain: topic, region and usage. The returned array consists of Synsets which have been augmented with this information: they hold an extra property called \"term_type\" which indicates which of the three domain types applies.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"dance.v.2\").then(function(synset){\r\n\tsynset.getDomainTerms().then(function(domain){\r\n\t\tconsole.log(util.inspect(domain, null, 3))\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 100429255,\r\n    words: \r\n     [ { lemma: 'dance' },\r\n       { lemma: 'dancing' },\r\n       { lemma: 'saltation' },\r\n       { lemma: 'terpsichore' } ],\r\n    definition: 'taking a series of rhythmical steps (and movements) in time to music',\r\n    pos: 'n',\r\n    lexdomain: 'noun.act',\r\n    term_type: 'topic' } ]\r\n```\r\n\r\n#### .getExamples(callback)\r\n\r\nReturns an array of sample sentences for the synset in question. \r\n\r\nExample: \r\n\r\n```\r\nwn.fetchSynset(\"bank.n.1\", function(err, synset){\r\n\tsynset.getExamples(function(err, data){\r\n\t\tconsole.log(data)\r\n\t});\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { synsetid: 109236472,\r\n    sampleid: 1,\r\n    sample: 'they pulled the canoe up on the bank' },\r\n  { synsetid: 109236472,\r\n    sampleid: 2,\r\n    sample: 'he sat on the bank of the river and watched the currents' } ]\r\n```\r\n\r\n#### .getLemmas(callback)\r\n\r\nReturns an array of *Word* objects which have a sense belonging to the synset.\r\n\r\nExample: \r\n```\r\nwn.fetchSynset(\"dog.n.1\", function(err, synset){\r\n\tsynset.getLemmas(function(err, data){ console.log(data) });\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'canis familiaris' },\r\n  { lemma: 'dog' },\r\n  { lemma: 'domestic dog' } ]\r\n```\r\n\r\n#### .getHypernyms(callback)\r\n\r\nA hypernym is a synset constitution a semantic field to which many other synsets can belong. This function looks up the direct hypernym of the synset and passes it to the callback function. \r\n\r\nExample:\r\n```\r\n// the synset king.n.10 is: king - (chess) the weakest but the most important piece\r\nwn.fetchSynset(\"king.n.10\").then(function(synset){\r\n\tsynset.getHypernyms().then(function(hypernym){\r\n\t\tconsole.log(util.inspect(hypernym, null, 3));\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n```\r\n[ { synsetid: 103018094,\r\n    words: [ { lemma: 'chess piece' }, { lemma: 'chessman' } ],\r\n    definition: 'any of 16 white and 16 black pieces used in playing the game of chess',\r\n    pos: 'n',\r\n    lexdomain: 'noun.artifact' } ]\r\n```\r\n\r\n#### .getHypernymsTree(callback)\r\n\r\nIn contrast to *.getHypernyms*, this function performs a recursive search to also retrieve the information about the hypernyms of the found hypernyms, yielding a hierarchical tree structure with the synsets who do not have any more hypernyms at the top. The returned array includes the found hypernyms as *Synset* objects, with an additional key named *hypernym* which containing its hypernym, again as an object of class *Synset*. \r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"bacteria.n.1\", function(err, synset){\r\n\tsynset.getHypernymsTree(function(err, data){\r\n\t\tconsole.log(util.inspect(data, null, 3));\r\n\t});\r\n});\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 101328932,\r\n    words: [ { lemma: 'micro-organism' }, { lemma: 'microorganism' } ],\r\n    definition: 'any organism of microscopic size',\r\n    pos: 'n',\r\n    lexdomain: 'noun.animal',\r\n    hypernym: \r\n     [ { synsetid: 100004475,\r\n         words: [Object],\r\n         definition: 'a living thing that has (or can develop) the ability to act or function independently',\r\n         pos: 'n',\r\n         lexdomain: 'noun.tops',\r\n         hypernym: [Object] } ] } ]\r\n```\r\n\r\n#### .getHyponyms(callback)\r\n\r\nThis function collects the hyponyms for the synset, where the hyponym of a synset is defined as a subordinate grouping. In doing so, the synset and its hyponym stand in a type-of relationship with each other. This function retrieves the \r\nhyponyms of a synset and returns them in array to the callback.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"american.n.3\").then(function(synset){\r\n\tconsole.log(synset)\r\n\tsynset.getHyponyms().then(function(hyponym){\r\n\t\tconsole.log(util.inspect(hyponym, null, 3))\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 109729069,\r\n    words: [ { lemma: 'creole' } ],\r\n    definition: 'a person of European descent born in the West Indies or Latin America',\r\n    pos: 'n',\r\n    lexdomain: 'noun.person' },\r\n  { synsetid: 109739652,\r\n    words: [ { lemma: 'latin american' }, { lemma: 'latino' } ],\r\n    definition: 'a native of Latin America',\r\n    pos: 'n',\r\n    lexdomain: 'noun.person' },\r\n  { synsetid: 109744643,\r\n    words: [ { lemma: 'north american' } ],\r\n    definition: 'a native or inhabitant of North America',\r\n    pos: 'n',\r\n    lexdomain: 'noun.person' },\r\n(...)\r\n]\r\n```\r\n\r\n#### .getHyponymsTree(callback)\r\n\r\nPerforms a recursive search and returns an array of hyponyms, which are again just *Synset* objects. However, they additionally possess a field called *hyponym* which includes their own hyponym etc. \r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"canadian.n.1\").then(function(synset){\r\n\tsynset.getHyponymsTree().then(function(hypernym){\r\n\t\t// only print first element of array to the console\r\n\t\tconsole.log(util.inspect(hypernym[0], null, 3));\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n```\r\n{ synsetid: 109716159,\r\n  words: [ { lemma: 'french canadian' } ],\r\n  definition: 'a Canadian descended from early French settlers and whose native language is French',\r\n  pos: 'n',\r\n  lexdomain: 'noun.person',\r\n  hyponym: \r\n   [ { synsetid: 109696564,\r\n       words: [ [Object] ],\r\n       definition: 'an early French settler in the Maritimes',\r\n       pos: 'n',\r\n       lexdomain: 'noun.person',\r\n       hyponym: [ [Object] ] },\r\n     { synsetid: 109716340,\r\n       words: [ [Object] ],\r\n       definition: 'informal term for Canadians in general and French Canadians in particular',\r\n       pos: 'n',\r\n       lexdomain: 'noun.person',\r\n       hyponym: [] } ] }\r\n```\r\n\r\n#### .getHolonyms(type, callback)\r\n\r\nReturns an array of holonyms for the given synset. Holonyms define the relationship between a part and a whole. Specifically, X is a holonym of Y if the latter is a part of X, for example an arm is part of a human being.\r\nThe function takes as a first argument the type of the holonym relationship, which can be either *part*, *member* or *substance* (or an array combining any two of those). If *null* is supplied, the function\r\nreturns all holonyms. \r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"feminist.n.1\", function(err, synset){\r\n\tsynset.getHolonyms(\"member\", function(err, data){ console.log(util.inspect(data, null, 3)); });\r\n})\r\n``` \r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 100802082,\r\n    words: \r\n     [ { lemma: 'feminism' },\r\n       { lemma: 'feminist movement' },\r\n       { lemma: 'women\\'s lib' },\r\n       { lemma: 'women\\'s liberation movement' } ],\r\n    definition: 'the movement aimed at equal rights for women',\r\n    pos: 'n',\r\n    lexdomain: 'noun.act' } ]\r\n```\r\n\r\n#### .getMeronyms(type, callback)\r\n\r\nMeronyms are the opposite of holonyms, i.e. X is a meronym of Y if X is a part of Y. The function takes as a first argument the type of the meronym \r\nrelationship, which can be either *part*, *member* or *substance* (or an array combining any two of those). If *null* is supplied, the function\r\nreturns all meronyms. The returned object is an array of synsets which are meronyms of the synset owning the method.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"finger.n.1\", function(err, synset){\r\n\tsynset.getMeronyms(\"part\",function(err, data){ \r\n\t  console.log(util.inspect(data, null, 3));\r\n\t});\r\n})\r\n```\r\n\r\nOutput: \r\n\r\n```\r\n[ { synsetid: 102443154,\r\n    words: [ { lemma: 'pad' } ],\r\n    definition: 'the fleshy cushion-like underside of an animal\\'s foot \r\n    or of a human\\'s finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.animal' },\r\n  { synsetid: 105574750,\r\n    words: [ { lemma: 'fingertip' } ],\r\n    definition: 'the end (tip) of a finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' },\r\n  { synsetid: 105591915,\r\n    words: [ { lemma: 'fingernail' } ],\r\n    definition: 'the nail at the end of a finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' },\r\n  { synsetid: 105592855,\r\n    words: \r\n     [ { lemma: 'knuckle' },\r\n       { lemma: 'knuckle joint' },\r\n       { lemma: 'metacarpophalangeal joint' } ],\r\n    definition: 'a joint of a finger when the fist is closed',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' } ]\r\n\r\n```\r\n\r\n#### .getSisterTerms(callback)\r\n\r\nFinds all sister terms for the synset in question, that is all other synsets which share a common hypernym. The object \r\npassed to the supplied callback function is an array consisting of the hypernym synset, which has an additional *hyponym*\r\nkey which holds an array of its hyponyms. For example, in a given deck of cards, the queen is one of three card types bearing a face. \r\nWhen asking WordNet to find the sister terms of a queen of cards, it firsts finds its hypernym and then correclty outputs \r\nthe sister terms as *jack* and *king*. See the example.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"queen.n.7\", function(err, synset){\r\n\tsynset.getSisterTerms(function(err, data){ console.log(util.inspect(data, null, 5)); });\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 103318973,\r\n    words: \r\n     [ { lemma: 'court card' },\r\n       { lemma: 'face card' },\r\n       { lemma: 'picture card' } ],\r\n    definition: 'one of the twelve cards in a deck bearing a picture of a face',\r\n    pos: 'n',\r\n    lexdomain: 'noun.artifact',\r\n    hyponym: \r\n     [ { synsetid: 103594280,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of four face cards in a deck bearing a picture of a young prince',\r\n         words: [ { lemma: 'jack' }, { lemma: 'knave' } ] },\r\n       { synsetid: 103623428,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of the four playing cards in a deck bearing the picture of a king',\r\n         words: [ { lemma: 'king' } ] },\r\n       { synsetid: 104039901,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of four face cards in a deck bearing a picture of a queen',\r\n         words: [ { lemma: 'queen' } ] } ] } ]\r\n``` \r\n\r\n#### .causeOf(callback)\r\n\r\nDefined for two verbs X and Y, where X causes the action of Y. The result set is an array consisting of the \r\nsynset(s) which are caused by the synset this method belongs to. \r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"leak.v.1\",function(err, synset){\r\n\tsynset.causeOf(function(err, data){\r\n\t\tconsole.log(data)\r\n\t});\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 200938019,\r\n    words: [ [Object], [Object], [Object] ],\r\n    definition: 'be released or become known; of news',\r\n    pos: 'v',\r\n    lexdomain: 'verb.communication' } ]\r\n```\r\n\r\n### Other Functions\r\n\r\n#### wn.print(input)\r\n\r\nThis utility function takes as its input an object of any class from the module and prints the content in a nicely formatted\r\nway to the terminal. An array of objects can also be supplied. \r\n\r\nExample:\r\n```  \r\nwn.fetchSynset(\"fish.n.1\").then(function(synsetArray){\r\n\tsynsetArray.getHypernymsTree().each(function(hypernym){\r\n\t\t\twn.print(hypernym);\r\n\t\t})\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\nS: (n) aquatic vertebrate (animal living wholly or chiefly in or on water)\r\n    S: (n) craniate, vertebrate (animals having a bony or cartilaginous skeleton with a segmented spinal  column and a large brain enclosed in a skull or cranium)\r\n        S: (n) chordate (any animal of the phylum Chordata having a notochord or spinal column)\r\n            S: (n) animal, animate being, beast, brute, creature, fauna (a living organism characterized by voluntary movement)\r\n                S: (n) being, organism (a living thing that has (or can develop) the ability to act or function independently)\r\n                    S: (n) animate thing, living thing (a living (or once living) entity)\r\n                        S: (n) unit, whole (an assemblage of parts that is regarded as a single entity)\r\n                            S: (n) object, physical object (a tangible and visible entity; an entity that can cast a shadow)\r\n                                S: (n) physical entity (an entity that has physical existence)\r\n                                    S: (n) entity (that which is perceived or known or inferred to have its own distinct existence (living or nonliving))\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}