{"name":"Node-wordnet-magic","tagline":"tools for working with Princeton's lexical database WordNet","body":"node-wordnet-magic\r\n==================\r\n\r\nA node.js module for working with Princeton's WordNet lexical database for the English language.\r\n\r\n[![NPM version](https://badge.fury.io/js/wordnet-magic.svg)](http://badge.fury.io/js/wordnet-magic)\r\n\r\n# Getting Started\r\n\r\n## What is it about?\r\n\r\n## Installation & Setup\r\n\r\nThe module is available through npm via\r\n\r\n```\r\nnpm install wordnet-magic\r\n``` \r\n\r\nInside node, the package can then be loaded as any other module:\r\n\r\n``` \r\nvar wn = require('wordnet-magic');\r\n``` \r\n\r\nHowever, the WordNet database has to be downloaded seperately and placed into the /data folder of the package directory. The package expects WordNet in SQLite format, which can be obtained from the URL \r\n[http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/](http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/). If for whatever reason you decide to place\r\nthe database file in another location, you have to tell the module as follows before using any of the other functions:\r\n\r\n``` \r\nwn.registerDatabase(<insert path here>);\r\n``` \r\n\r\n## Features\r\n\r\n- module provides access to most of WordNet's resources to be used for various natural language processing tasks \r\n- word type detection\r\n- abilitiy to retrieve hypernyms, synonyms, homonyms etc. for a given synset \r\n- asynchronous module supporting both classical node.js callbacks and promises implemented via Bluebird\r\n- implements WordNet's Morphy to find base words of inflected forms\r\n\r\n## Example Usage\r\n\r\n\r\n\r\n\r\nFurther example codes is distributed in the *examples* subdirectory of the package repository.\r\n\r\n# API\r\n\r\n## Callbacks and Promises \r\n\r\nDue to the asynchronous nature of JavaScript's I/O operations, all functions in the module are asynchronous by nature. Hence, following conventional design, a callback function has to be passed to the function as the last argument. This callback function  has two parameters: an error object which is *null* if no error is thrown and a second parameter which is the returned value from the invoked function. \r\n\r\nAlternatively, the wordnet-magic package implements promises via the [Bluebird](https://github.com/petkaantonov/bluebird) package. In this documentation, we stick to the callback style as it is more conventional, although one might argue that using promises results in clear code. \r\n\r\nThe following example demonstrates the use of both callbacks and promises when using the wordnet-magic module:\r\n\r\n```\r\nwn.isNoun(\"callback\", function(err, data){ console.log(data)});\r\nwn.isNoun(\"promise\").then(console.log);\r\n```\r\n\r\n## Word\r\n\r\nThe package includes a word class which is a simple wrapper for any user-supplied string \r\nproviding methods for accessing information provided by WordNet about the word. A word is created as follows:\r\n\r\n```\r\nvar word = new wn.Word(\"cat\");\r\n```\r\n\r\nThe constructor accepts as a second argument a part-of-speech type. Hence, if supplied, *pos* must be \r\neither *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective.\r\n\r\nInvoking the constructor function returns a new object with the following properties and methods:\r\n\r\n### Properties\r\n\r\n#### .lemma\r\n\r\nThis key holds the user-supplied word passed to the constructor function at creation of the object. \r\n\r\n#### .pos (optional)\r\n\r\nIf the word was created by passing the constructor function a part-of-speech type, this key will hold the supplied value. Otherwise it is *undefined*.\r\n\r\n### Methods\r\n\r\n#### .getSynsets(callback)\r\n\r\nQueries WordNet for an array of Synset objects matching the word and passes them to the callback function. If the part-of-speech\r\ntype exists for word owning the method, the search is restricted to only return synsets of said type. \r\n\r\nExample:\r\n```\r\nvar kiss = new wordNet.Word(\"kiss\",\"v\");\r\nkiss.getSynsets(function(err, data){\r\n\tconsole.log(util.inspect(data, null, 3));\r\n});\r\n``` \r\n\r\nOutput:\r\n```\r\n[ { synsetid: 201433863,\r\n    words: \r\n     [ { lemma: 'buss' },\r\n       { lemma: 'kiss' },\r\n       { lemma: 'osculate' },\r\n       { lemma: 'snog' } ],\r\n    definition: 'touch with the lips or press the lips (against \r\n    someone\\'s mouth or other body part) \r\n    as an expression of love, greeting, etc.',\r\n    pos: 'v',\r\n    lexdomain: 'verb.contact' },\r\n  { synsetid: 201434356,\r\n    words: [ { lemma: 'kiss' } ],\r\n    definition: 'touch lightly or gently',\r\n    pos: 'v',\r\n    lexdomain: 'verb.contact' } ]\r\n```\r\n\r\n#### .getAntonyms(callback)\r\n\r\nRetrieves an array of objects containing the antonyms (= words opposite in meaning, e.g. black and white) for \r\nthe supplied word and passes it to the supplied callback function. The objects have three keys, the orginal *lemma*, the \r\n*synset* for which the antonym relationship exists and the *antonym* itself. \r\n\r\nExample:\r\n```\r\nvar high = new wn.Word(\"high\");\r\nhigh.getAntonyms(function(err, antonymArray){\r\n\tconsole.log(antonymArray);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: 'greater than normal in degree or intensity or amount' },\r\n  { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: '(literal meaning) being at or having a relatively great or \r\n    specific elevation or upward extension\r\n     (sometimes used in combinations like knee-high\\')' },\r\n  { lemma: 'high',\r\n    antonym: 'low',\r\n    synset: 'used of sounds and voices; high in pitch or frequency' } ]\r\n```\r\n\r\n## Morphy\r\nThe package implements Morphy, a set of rules part of WordNet which try to determine the base form of a given inflected form. This\r\nfunctionality is important insofar as words are stored only in their base form in the data base, and not taking this into account will likely\r\nproduce bad results. A detailed explanation of the steps Morphy takes to determine the base form can be found in the original documentation:\r\n[https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html](https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html)\r\n\r\n#### wn.morphy(word, pos, callback)\r\nReturns the base form for an inflected word to the callback function. As a second argument, the function takes a character denoting the part of speech,\r\nwhich can take one of the values *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective. Internally,\r\nthe function performs different steps depending on the type of the word. If *pos* is not supplied, all five possibilities are checked and the results\r\naggregated. \r\n\r\nThen the function returns an array of object(s) with two properties, *lemma* and *part_of_speech*. These are themselves instances of the basic Word class, \r\nextended by having the word type as an extra key. \r\nThe first is the matching base word itself and the second its word type. \r\n\r\nExample:\r\n```\r\nwn.morphy(\"loci\", \"n\" , function(err, data){\r\n\tconsole.log(data);\r\n})\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'locus', part_of_speech: 'n' } ]\r\n```\r\n\r\n## Word type checking\r\n\r\nThe module provides several functions for checking whether a given word belongs to a certain word type. All these functions\r\ntake as their first argument the word in question and as their second argument a callback function. Internally, the functions\r\nfirst use *morphy* to find the base form of the supplied word and then check whether the returned array of objects from *morphy*\r\ncontains an entry of the word type in question.\r\n\r\n#### wn.isNoun(word, callback)\r\n\r\nReturns *true* if *word* is a noun, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isNoun(\"happy\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\nfalse\r\n```\r\n\r\n#### wn.isVerb(word, callback)\r\n\r\nReturns *true* if *word* is a verb, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isVerb(\"kill\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n#### wn.isAdjective(word, callback)\r\n\r\nReturns *true* if *word* is a adjective, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isAdjective(\"filthy\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n#### wn.isAdverb(word, callback)\r\n\r\nReturns *true* if *word* is a adverb, *false* otherwise to the supplied callback.\r\n\r\nExample:\r\n```\r\nwn.isAdverb(\"helpfully\", function(err, data){\r\n\tconsole.log(data);\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\ntrue\r\n```\r\n\r\n## Synset\r\n\r\nIn WordNet, a synset is a unique concept which may have many words attached to it. These *synonyms* then share the common \r\nmeaning of the synset. WordNet separates the individual words from the synsets as the former can belong to many different \r\nsynsets: for example, the word *bank* can refer both to the financial institution and a river bank. \r\n\r\nThe most common method to create synsets in the wordnet-magic module is to invoke the .getSynsets() method of a Word object. However,\r\neach synset can also be identified by a *string*  consisting of three parts separated by dots such as \"king.n.1\", where\r\nthe first part denotes a word associated with the synset, the second its word type and the third an incrementing integer for each sense (embodied in the synset) \r\nof the word. In this case, the function fetchSynset(*string*) can be used to retrieve the synset information.\r\n\r\nExample: \r\n\r\n```\r\nwn.fetchSynset(\"dog.n.1\", function(err, synset){\r\n console.log(synset);\t\r\n});\r\n``` \r\n\r\nOutput:\r\n``` \r\n{ synsetid: 102086723,\r\n  words: \r\n   [ { lemma: 'canis familiaris' },\r\n     { lemma: 'dog' },\r\n     { lemma: 'domestic dog' } ],\r\n  definition: 'a member of the genus Canis (probably descended from the common wolf) \r\n  that has been domesticated by man since prehistoric times; occurs in many breeds',\r\n  pos: 'n',\r\n  lexdomain: 'noun.animal' }\r\n``` \r\n\r\n### Properties\r\n\r\nAs we can see from above output, an object of the Synset class has the following properties:\r\n\r\n#### .synsetid\r\n\r\n*For internal use*. Integer which acts as a unique identifier of the synset. \r\n\r\n#### .words\r\n\r\nNot filled upon creation of a synset, this is a placeholder which can hold all the words associated with the synset in question.\r\n\r\n#### .definition\r\n\r\nA string holding the definition of the synset.\r\n\r\n#### .pos\r\n\r\nThe part of speech of the word, taking one of the values *n* for noun, *v* for verb, *a* for adjective, *r* for adverb and *s* for satellite adjective.  \r\n\r\n#### .lexdomain\r\n\r\nThe lexical domain of the synset. Each domain category is composed of the word type followed by a \r\ndot and then the category name. WordNet has implemented the following domain categories:\r\n\r\n- adj: all, pert, ppl\r\n- adv: all\r\n- noun: tops, act, animal, artifact, attribute, body, cognition, communication\r\nevent, feeling, food, group, location, motive, object, person\r\nphenomenon, plant, possession, process, quantity, linkdef, shape, state\r\nsubstance, time\r\n- verb: body, change, cognition, communication, competition, consumption, contact, \r\ncreation, emotion, motion, perception, possession, social, stative, weather\r\n\r\n### Methods\r\n\r\nA synset object is equipped with the following methods:\r\n\r\n#### .getExamples(callback)\r\n\r\nReturns an array of sample sentences for the synset in question. \r\n\r\nExample: \r\n\r\n```\r\nwn.fetchSynset(\"bank.n.1\", function(err, synset){\r\n\tsynset.getExamples(function(err, data){\r\n\t\tconsole.log(data)\r\n\t});\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { synsetid: 109236472,\r\n    sampleid: 1,\r\n    sample: 'they pulled the canoe up on the bank' },\r\n  { synsetid: 109236472,\r\n    sampleid: 2,\r\n    sample: 'he sat on the bank of the river and watched the currents' } ]\r\n```\r\n\r\n#### .getLemmas(callback)\r\n\r\nReturns an array of *Word* objects which have a sense belonging to the synset.\r\n\r\nExample: \r\n```\r\nwn.fetchSynset(\"dog.n.1\", function(err, synset){\r\n\tsynset.getLemmas(function(err, data){ console.log(data) });\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\n[ { lemma: 'canis familiaris' },\r\n  { lemma: 'dog' },\r\n  { lemma: 'domestic dog' } ]\r\n```\r\n\r\n#### .getHypernyms(callback)\r\n\r\n#### .getHypernymsTree(callback)\r\n\r\n#### .getHyponyms(callback)\r\n\r\n#### .getHyponymsTree(callback)\r\n\r\n#### .getHolonyms(type, callback)\r\n\r\nReturns an array of holonyms for the given synset. Holonyms define the relationship between a part and a whole. Specifically, X is a holonym of Y if the latter is a part of X, for example an arm is part of a human being.\r\nThe function takes as a first argument the type of the holonym relationship, which can be either *part*, *member* or *substance* (or an array combining any two of those). If *null* is supplied, the function\r\nreturns all holonyms. \r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"feminist.n.1\", function(err, synset){\r\n\tsynset.getHolonyms(\"member\", function(err, data){ console.log(util.inspect(data, null, 3)); });\r\n})\r\n``` \r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 100802082,\r\n    words: \r\n     [ { lemma: 'feminism' },\r\n       { lemma: 'feminist movement' },\r\n       { lemma: 'women\\'s lib' },\r\n       { lemma: 'women\\'s liberation movement' } ],\r\n    definition: 'the movement aimed at equal rights for women',\r\n    pos: 'n',\r\n    lexdomain: 'noun.act' } ]\r\n```\r\n\r\n#### .getMeronyms(type, callback)\r\n\r\nMeronyms are the opposite of holonyms, i.e. X is a meronym of Y if X is a part of Y. The function takes as a first argument the type of the meronym \r\nrelationship, which can be either *part*, *member* or *substance* (or an array combining any two of those). If *null* is supplied, the function\r\nreturns all meronyms. The returned object is an array of synsets which are meronyms of the synset owning the method.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"finger.n.1\", function(err, synset){\r\n\tsynset.getMeronyms(\"part\",function(err, data){ \r\n\t  console.log(util.inspect(data, null, 3));\r\n\t});\r\n})\r\n```\r\n\r\nOutput: \r\n\r\n```\r\n[ { synsetid: 102443154,\r\n    words: [ { lemma: 'pad' } ],\r\n    definition: 'the fleshy cushion-like underside of an animal\\'s foot \r\n    or of a human\\'s finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.animal' },\r\n  { synsetid: 105574750,\r\n    words: [ { lemma: 'fingertip' } ],\r\n    definition: 'the end (tip) of a finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' },\r\n  { synsetid: 105591915,\r\n    words: [ { lemma: 'fingernail' } ],\r\n    definition: 'the nail at the end of a finger',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' },\r\n  { synsetid: 105592855,\r\n    words: \r\n     [ { lemma: 'knuckle' },\r\n       { lemma: 'knuckle joint' },\r\n       { lemma: 'metacarpophalangeal joint' } ],\r\n    definition: 'a joint of a finger when the fist is closed',\r\n    pos: 'n',\r\n    lexdomain: 'noun.body' } ]\r\n\r\n```\r\n\r\n#### .getSisterTerms(callback)\r\n\r\nFinds all sister terms for the synset in question, that is all other synsets which share a common hypernym. The object \r\npassed to the supplied callback function is an array consisting of the hypernym synset, which has an additional *hyponym*\r\nkey which holds an array of its hyponyms. For example, in a given deck of cards, the queen is one of three card types bearing a face. \r\nWhen asking WordNet to find the sister terms of a queen of cards, it firsts finds its hypernym and then correclty outputs \r\nthe sister terms as *jack* and *king*. See the example.\r\n\r\nExample:\r\n\r\n```\r\nwn.fetchSynset(\"queen.n.7\", function(err, synset){\r\n\tsynset.getSisterTerms(function(err, data){ console.log(util.inspect(data, null, 5)); });\r\n})\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[ { synsetid: 103318973,\r\n    words: \r\n     [ { lemma: 'court card' },\r\n       { lemma: 'face card' },\r\n       { lemma: 'picture card' } ],\r\n    definition: 'one of the twelve cards in a deck bearing a picture of a face',\r\n    pos: 'n',\r\n    lexdomain: 'noun.artifact',\r\n    hyponym: \r\n     [ { synsetid: 103594280,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of four face cards in a deck bearing a picture of a young prince',\r\n         words: [ { lemma: 'jack' }, { lemma: 'knave' } ] },\r\n       { synsetid: 103623428,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of the four playing cards in a deck bearing the picture of a king',\r\n         words: [ { lemma: 'king' } ] },\r\n       { synsetid: 104039901,\r\n         pos: 'n',\r\n         lexdomain: 'noun.artifact',\r\n         definition: 'one of four face cards in a deck bearing a picture of a queen',\r\n         words: [ { lemma: 'queen' } ] } ] } ]\r\n``` \r\n\r\n#### .causeOf()\r\n\r\n### Other Functions\r\n\r\n#### wn.print(input)\r\n\r\nThis utility function takes as its input an object of any class from the module and prints the content in a nicely formatted\r\nway to the terminal. An array of objects can also be supplied. \r\n\r\nExample:\r\n```  \r\nwn.fetchSynset(\"fish.n.1\").then(function(synsetArray){\r\n\tsynsetArray.getHypernymsTree().each(function(hypernym){\r\n\t\t\twn.print(hypernym);\r\n\t\t})\r\n});\r\n```\r\n\r\nOutput:\r\n```\r\nS: (n) aquatic vertebrate (animal living wholly or chiefly in or on water)\r\n    S: (n) craniate, vertebrate (animals having a bony or cartilaginous skeleton with a segmented spinal column and a large brain enclosed in a skull or cranium)\r\n        S: (n) chordate (any animal of the phylum Chordata having a notochord or spinal column)\r\n            S: (n) animal, animate being, beast, brute, creature, fauna (a living organism characterized by voluntary movement)\r\n                S: (n) being, organism (a living thing that has (or can develop) the ability to act or function independently)\r\n                    S: (n) animate thing, living thing (a living (or once living) entity)\r\n                        S: (n) unit, whole (an assemblage of parts that is regarded as a single entity)\r\n                            S: (n) object, physical object (a tangible and visible entity; an entity that can cast a shadow)\r\n                                S: (n) physical entity (an entity that has physical existence)\r\n                                    S: (n) entity (that which is perceived or known or inferred to have its own distinct existence (living or nonliving))\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}