<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Node-wordnet-magic by Planeshifter</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Node-wordnet-magic</h1>
        <h2>tools for working with Princeton&#39;s lexical database WordNet</h2>
        <a href="https://github.com/Planeshifter/node-wordnet-magic" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="node-wordnet-magic" class="anchor" href="#node-wordnet-magic"><span class="octicon octicon-link"></span></a>node-wordnet-magic</h1>

<p>A node.js module for working with Princeton's WordNet lexical database for the English language.</p>

<p><a href="http://badge.fury.io/js/wordnet-magic"><img src="https://badge.fury.io/js/wordnet-magic.svg" alt="NPM version"></a></p>

<h1>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h1>

<h2>
<a name="what-is-it-about" class="anchor" href="#what-is-it-about"><span class="octicon octicon-link"></span></a>What is it about?</h2>

<h2>
<a name="installation--setup" class="anchor" href="#installation--setup"><span class="octicon octicon-link"></span></a>Installation &amp; Setup</h2>

<p>The module is available through npm via</p>

<pre><code>npm install wordnet-magic
</code></pre>

<p>Inside node, the package can then be loaded as any other module:</p>

<pre><code>var wn = require('wordnet-magic');
</code></pre>

<p>However, the WordNet database has to be downloaded seperately and placed into the /data folder of the package directory. The package expects WordNet in SQLite format, which can be obtained from the URL 
<a href="http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/">http://sourceforge.net/projects/wnsql/files/wnsql3/sqlite/</a>. If for whatever reason you decide to place
the database file in another location, you have to tell the module as follows before using any of the other functions:</p>

<pre><code>wn.registerDatabase(&lt;insert path here&gt;);
</code></pre>

<h2>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>module provides access to most of WordNet's resources to be used for various natural language processing tasks </li>
<li>word type detection</li>
<li>abilitiy to retrieve hypernyms, synonyms, homonyms etc. for a given synset </li>
<li>asynchronous module supporting both classical node.js callbacks and promises implemented via Bluebird</li>
<li>implements WordNet's Morphy to find base words of inflected forms</li>
</ul><h2>
<a name="example-usage" class="anchor" href="#example-usage"><span class="octicon octicon-link"></span></a>Example Usage</h2>

<p>Further example codes is distributed in the <em>examples</em> subdirectory of the package repository.</p>

<h1>
<a name="api" class="anchor" href="#api"><span class="octicon octicon-link"></span></a>API</h1>

<h2>
<a name="callbacks-and-promises" class="anchor" href="#callbacks-and-promises"><span class="octicon octicon-link"></span></a>Callbacks and Promises</h2>

<p>Due to the asynchronous nature of JavaScript's I/O operations, all functions in the module are asynchronous by nature. Hence, following conventional design, a callback function has to be passed to the function as the last argument. This callback function  has two parameters: an error object which is <em>null</em> if no error is thrown and a second parameter which is the returned value from the invoked function. </p>

<p>Alternatively, the wordnet-magic package implements promises via the <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> package. In this documentation, we stick to the callback style as it is more conventional, although one might argue that using promises results in clear code. </p>

<p>The following example demonstrates the use of both callbacks and promises when using the wordnet-magic module:</p>

<pre><code>wn.isNoun("callback", function(err, data){ console.log(data)});
wn.isNoun("promise").then(console.log);
</code></pre>

<h2>
<a name="word" class="anchor" href="#word"><span class="octicon octicon-link"></span></a>Word</h2>

<p>The package includes a word class which is a simple wrapper for any user-supplied string 
providing methods for accessing information provided by WordNet about the word. A word is created as follows:</p>

<pre><code>var word = new wn.Word("cat");
</code></pre>

<p>The constructor accepts as a second argument a part-of-speech type. Hence, if supplied, <em>pos</em> must be 
either <em>n</em> for noun, <em>v</em> for verb, <em>a</em> for adjective, <em>r</em> for adverb and <em>s</em> for satellite adjective.</p>

<p>Invoking the constructor function returns a new object with the following properties and methods:</p>

<h3>
<a name="properties" class="anchor" href="#properties"><span class="octicon octicon-link"></span></a>Properties</h3>

<h4>
<a name="lemma" class="anchor" href="#lemma"><span class="octicon octicon-link"></span></a>.lemma</h4>

<p>This key holds the user-supplied word passed to the constructor function at creation of the object. </p>

<h4>
<a name="pos-optional" class="anchor" href="#pos-optional"><span class="octicon octicon-link"></span></a>.pos (optional)</h4>

<p>If the word was created by passing the constructor function a part-of-speech type, this key will hold the supplied value. Otherwise it is <em>undefined</em>.</p>

<h3>
<a name="methods" class="anchor" href="#methods"><span class="octicon octicon-link"></span></a>Methods</h3>

<h4>
<a name="getsynsetscallback" class="anchor" href="#getsynsetscallback"><span class="octicon octicon-link"></span></a>.getSynsets(callback)</h4>

<p>Queries WordNet for an array of Synset objects matching the word and passes them to the callback function. If the part-of-speech
type exists for word owning the method, the search is restricted to only return synsets of said type. </p>

<p>Example:</p>

<pre><code>var kiss = new wordNet.Word("kiss","v");
kiss.getSynsets(function(err, data){
    console.log(util.inspect(data, null, 3));
});
</code></pre>

<p>Output:</p>

<pre><code>[ { synsetid: 201433863,
    words: 
     [ { lemma: 'buss' },
       { lemma: 'kiss' },
       { lemma: 'osculate' },
       { lemma: 'snog' } ],
    definition: 'touch with the lips or press the lips (against 
    someone\'s mouth or other body part) 
    as an expression of love, greeting, etc.',
    pos: 'v',
    lexdomain: 'verb.contact' },
  { synsetid: 201434356,
    words: [ { lemma: 'kiss' } ],
    definition: 'touch lightly or gently',
    pos: 'v',
    lexdomain: 'verb.contact' } ]
</code></pre>

<h4>
<a name="getantonymscallback" class="anchor" href="#getantonymscallback"><span class="octicon octicon-link"></span></a>.getAntonyms(callback)</h4>

<p>Retrieves an array of objects containing the antonyms (= words opposite in meaning, e.g. black and white) for 
the supplied word and passes it to the supplied callback function. The objects have three keys, the orginal <em>lemma</em>, the 
<em>synset</em> for which the antonym relationship exists and the <em>antonym</em> itself. </p>

<p>Example:</p>

<pre><code>var high = new wn.Word("high");
high.getAntonyms(function(err, antonymArray){
    console.log(antonymArray);
});
</code></pre>

<p>Output:</p>

<pre><code>[ { lemma: 'high',
    antonym: 'low',
    synset: 'greater than normal in degree or intensity or amount' },
  { lemma: 'high',
    antonym: 'low',
    synset: '(literal meaning) being at or having a relatively great or 
    specific elevation or upward extension
     (sometimes used in combinations like knee-high\')' },
  { lemma: 'high',
    antonym: 'low',
    synset: 'used of sounds and voices; high in pitch or frequency' } ]
</code></pre>

<h2>
<a name="morphy" class="anchor" href="#morphy"><span class="octicon octicon-link"></span></a>Morphy</h2>

<p>The package implements Morphy, a set of rules part of WordNet which try to determine the base form of a given inflected form. This
functionality is important insofar as words are stored only in their base form in the data base, and not taking this into account will likely
produce bad results. A detailed explanation of the steps Morphy takes to determine the base form can be found in the original documentation:
<a href="https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html">https://wordnet.princeton.edu/wordnet/man/morphy.7WN.html</a></p>

<h4>
<a name="wnmorphyword-pos-callback" class="anchor" href="#wnmorphyword-pos-callback"><span class="octicon octicon-link"></span></a>wn.morphy(word, pos, callback)</h4>

<p>Returns the base form for an inflected word to the callback function. As a second argument, the function takes a character denoting the part of speech,
which can take one of the values <em>n</em> for noun, <em>v</em> for verb, <em>a</em> for adjective, <em>r</em> for adverb and <em>s</em> for satellite adjective. Internally,
the function performs different steps depending on the type of the word. If <em>pos</em> is not supplied, all five possibilities are checked and the results
aggregated. </p>

<p>Then the function returns an array of object(s) with two properties, <em>lemma</em> and <em>part_of_speech</em>. These are themselves instances of the basic Word class, 
extended by having the word type as an extra key. 
The first is the matching base word itself and the second its word type. </p>

<p>Example:</p>

<pre><code>wn.morphy("loci", "n" , function(err, data){
    console.log(data);
})
</code></pre>

<p>Output:</p>

<pre><code>[ { lemma: 'locus', part_of_speech: 'n' } ]
</code></pre>

<h2>
<a name="word-type-checking" class="anchor" href="#word-type-checking"><span class="octicon octicon-link"></span></a>Word type checking</h2>

<p>The module provides several functions for checking whether a given word belongs to a certain word type. All these functions
take as their first argument the word in question and as their second argument a callback function. Internally, the functions
first use <em>morphy</em> to find the base form of the supplied word and then check whether the returned array of objects from <em>morphy</em>
contains an entry of the word type in question.</p>

<h4>
<a name="wnisnounword-callback" class="anchor" href="#wnisnounword-callback"><span class="octicon octicon-link"></span></a>wn.isNoun(word, callback)</h4>

<p>Returns <em>true</em> if <em>word</em> is a noun, <em>false</em> otherwise to the supplied callback.</p>

<p>Example:</p>

<pre><code>wn.isNoun("happy", function(err, data){
    console.log(data);
});
</code></pre>

<p>Output:</p>

<pre><code>false
</code></pre>

<h4>
<a name="wnisverbword-callback" class="anchor" href="#wnisverbword-callback"><span class="octicon octicon-link"></span></a>wn.isVerb(word, callback)</h4>

<p>Returns <em>true</em> if <em>word</em> is a verb, <em>false</em> otherwise to the supplied callback.</p>

<p>Example:</p>

<pre><code>wn.isVerb("kill", function(err, data){
    console.log(data);
});
</code></pre>

<p>Output:</p>

<pre><code>true
</code></pre>

<h4>
<a name="wnisadjectiveword-callback" class="anchor" href="#wnisadjectiveword-callback"><span class="octicon octicon-link"></span></a>wn.isAdjective(word, callback)</h4>

<p>Returns <em>true</em> if <em>word</em> is a adjective, <em>false</em> otherwise to the supplied callback.</p>

<p>Example:</p>

<pre><code>wn.isAdjective("filthy", function(err, data){
    console.log(data);
});
</code></pre>

<p>Output:</p>

<pre><code>true
</code></pre>

<h4>
<a name="wnisadverbword-callback" class="anchor" href="#wnisadverbword-callback"><span class="octicon octicon-link"></span></a>wn.isAdverb(word, callback)</h4>

<p>Returns <em>true</em> if <em>word</em> is a adverb, <em>false</em> otherwise to the supplied callback.</p>

<p>Example:</p>

<pre><code>wn.isAdverb("helpfully", function(err, data){
    console.log(data);
});
</code></pre>

<p>Output:</p>

<pre><code>true
</code></pre>

<h2>
<a name="synset" class="anchor" href="#synset"><span class="octicon octicon-link"></span></a>Synset</h2>

<p>In WordNet, a synset is a unique concept which may have many words attached to it. These <em>synonyms</em> then share the common 
meaning of the synset. WordNet separates the individual words from the synsets as the former can belong to many different 
synsets: for example, the word <em>bank</em> can refer both to the financial institution and a river bank. </p>

<p>The most common method to create synsets in the wordnet-magic module is to invoke the .getSynsets() method of a Word object. However,
each synset can also be identified by a <em>string</em>  consisting of three parts separated by dots such as "king.n.1", where
the first part denotes a word associated with the synset, the second its word type and the third an incrementing integer for each sense (embodied in the synset) 
of the word. In this case, the function fetchSynset(<em>string</em>) can be used to retrieve the synset information.</p>

<p>Example: </p>

<pre><code>wn.fetchSynset("dog.n.1", function(err, synset){
 console.log(synset);   
});
</code></pre>

<p>Output:</p>

<pre><code>{ synsetid: 102086723,
  words: 
   [ { lemma: 'canis familiaris' },
     { lemma: 'dog' },
     { lemma: 'domestic dog' } ],
  definition: 'a member of the genus Canis (probably descended from the common wolf) 
  that has been domesticated by man since prehistoric times; occurs in many breeds',
  pos: 'n',
  lexdomain: 'noun.animal' }
</code></pre>

<h3>
<a name="properties-1" class="anchor" href="#properties-1"><span class="octicon octicon-link"></span></a>Properties</h3>

<p>As we can see from above output, an object of the Synset class has the following properties:</p>

<h4>
<a name="synsetid" class="anchor" href="#synsetid"><span class="octicon octicon-link"></span></a>.synsetid</h4>

<p><em>For internal use</em>. Integer which acts as a unique identifier of the synset. </p>

<h4>
<a name="words" class="anchor" href="#words"><span class="octicon octicon-link"></span></a>.words</h4>

<p>Not filled upon creation of a synset, this is a placeholder which can hold all the words associated with the synset in question.</p>

<h4>
<a name="definition" class="anchor" href="#definition"><span class="octicon octicon-link"></span></a>.definition</h4>

<p>A string holding the definition of the synset.</p>

<h4>
<a name="pos" class="anchor" href="#pos"><span class="octicon octicon-link"></span></a>.pos</h4>

<p>The part of speech of the word, taking one of the values <em>n</em> for noun, <em>v</em> for verb, <em>a</em> for adjective, <em>r</em> for adverb and <em>s</em> for satellite adjective.  </p>

<h4>
<a name="lexdomain" class="anchor" href="#lexdomain"><span class="octicon octicon-link"></span></a>.lexdomain</h4>

<p>The lexical domain of the synset. Each domain category is composed of the word type followed by a 
dot and then the category name. WordNet has implemented the following domain categories:</p>

<ul>
<li>adj: all, pert, ppl</li>
<li>adv: all</li>
<li>noun: tops, act, animal, artifact, attribute, body, cognition, communication
event, feeling, food, group, location, motive, object, person
phenomenon, plant, possession, process, quantity, linkdef, shape, state
substance, time</li>
<li>verb: body, change, cognition, communication, competition, consumption, contact, 
creation, emotion, motion, perception, possession, social, stative, weather</li>
</ul><h3>
<a name="methods-1" class="anchor" href="#methods-1"><span class="octicon octicon-link"></span></a>Methods</h3>

<p>A synset object is equipped with the following methods:</p>

<h4>
<a name="getexamplescallback" class="anchor" href="#getexamplescallback"><span class="octicon octicon-link"></span></a>.getExamples(callback)</h4>

<p>Returns an array of sample sentences for the synset in question. </p>

<p>Example: </p>

<pre><code>wn.fetchSynset("bank.n.1", function(err, synset){
    synset.getExamples(function(err, data){
        console.log(data)
    });
});
</code></pre>

<p>Output:</p>

<pre><code>[ { synsetid: 109236472,
    sampleid: 1,
    sample: 'they pulled the canoe up on the bank' },
  { synsetid: 109236472,
    sampleid: 2,
    sample: 'he sat on the bank of the river and watched the currents' } ]
</code></pre>

<h4>
<a name="getlemmascallback" class="anchor" href="#getlemmascallback"><span class="octicon octicon-link"></span></a>.getLemmas(callback)</h4>

<p>Returns an array of <em>Word</em> objects which have a sense belonging to the synset.</p>

<p>Example: </p>

<pre><code>wn.fetchSynset("dog.n.1", function(err, synset){
    synset.getLemmas(function(err, data){ console.log(data) });
});
</code></pre>

<p>Output:</p>

<pre><code>[ { lemma: 'canis familiaris' },
  { lemma: 'dog' },
  { lemma: 'domestic dog' } ]
</code></pre>

<h4>
<a name="gethypernymscallback" class="anchor" href="#gethypernymscallback"><span class="octicon octicon-link"></span></a>.getHypernyms(callback)</h4>

<h4>
<a name="gethypernymstreecallback" class="anchor" href="#gethypernymstreecallback"><span class="octicon octicon-link"></span></a>.getHypernymsTree(callback)</h4>

<h4>
<a name="gethyponymscallback" class="anchor" href="#gethyponymscallback"><span class="octicon octicon-link"></span></a>.getHyponyms(callback)</h4>

<h4>
<a name="gethyponymstreecallback" class="anchor" href="#gethyponymstreecallback"><span class="octicon octicon-link"></span></a>.getHyponymsTree(callback)</h4>

<h4>
<a name="getholonymstype-callback" class="anchor" href="#getholonymstype-callback"><span class="octicon octicon-link"></span></a>.getHolonyms(type, callback)</h4>

<p>Returns an array of holonyms for the given synset. Holonyms define the relationship between a part and a whole. Specifically, X is a holonym of Y if the latter is a part of X, for example an arm is part of a human being.
The function takes as a first argument the type of the holonym relationship, which can be either <em>part</em>, <em>member</em> or <em>substance</em> (or an array combining any two of those). If <em>null</em> is supplied, the function
returns all holonyms. </p>

<p>Example:</p>

<pre><code>wn.fetchSynset("feminist.n.1", function(err, synset){
    synset.getHolonyms("member", function(err, data){ console.log(util.inspect(data, null, 3)); });
})
</code></pre>

<p>Output:</p>

<pre><code>[ { synsetid: 100802082,
    words: 
     [ { lemma: 'feminism' },
       { lemma: 'feminist movement' },
       { lemma: 'women\'s lib' },
       { lemma: 'women\'s liberation movement' } ],
    definition: 'the movement aimed at equal rights for women',
    pos: 'n',
    lexdomain: 'noun.act' } ]
</code></pre>

<h4>
<a name="getmeronymstype-callback" class="anchor" href="#getmeronymstype-callback"><span class="octicon octicon-link"></span></a>.getMeronyms(type, callback)</h4>

<p>Meronyms are the opposite of holonyms, i.e. X is a meronym of Y if X is a part of Y. The function takes as a first argument the type of the meronym 
relationship, which can be either <em>part</em>, <em>member</em> or <em>substance</em> (or an array combining any two of those). If <em>null</em> is supplied, the function
returns all meronyms. The returned object is an array of synsets which are meronyms of the synset owning the method.</p>

<p>Example:</p>

<pre><code>wn.fetchSynset("finger.n.1", function(err, synset){
    synset.getMeronyms("part",function(err, data){ 
      console.log(util.inspect(data, null, 3));
    });
})
</code></pre>

<p>Output: </p>

<pre><code>[ { synsetid: 102443154,
    words: [ { lemma: 'pad' } ],
    definition: 'the fleshy cushion-like underside of an animal\'s foot 
    or of a human\'s finger',
    pos: 'n',
    lexdomain: 'noun.animal' },
  { synsetid: 105574750,
    words: [ { lemma: 'fingertip' } ],
    definition: 'the end (tip) of a finger',
    pos: 'n',
    lexdomain: 'noun.body' },
  { synsetid: 105591915,
    words: [ { lemma: 'fingernail' } ],
    definition: 'the nail at the end of a finger',
    pos: 'n',
    lexdomain: 'noun.body' },
  { synsetid: 105592855,
    words: 
     [ { lemma: 'knuckle' },
       { lemma: 'knuckle joint' },
       { lemma: 'metacarpophalangeal joint' } ],
    definition: 'a joint of a finger when the fist is closed',
    pos: 'n',
    lexdomain: 'noun.body' } ]

</code></pre>

<h4>
<a name="getsistertermscallback" class="anchor" href="#getsistertermscallback"><span class="octicon octicon-link"></span></a>.getSisterTerms(callback)</h4>

<p>Finds all sister terms for the synset in question, that is all other synsets which share a common hypernym. The object 
passed to the supplied callback function is an array consisting of the hypernym synset, which has an additional <em>hyponym</em>
key which holds an array of its hyponyms. For example, in a given deck of cards, the queen is one of three card types bearing a face. 
When asking WordNet to find the sister terms of a queen of cards, it firsts finds its hypernym and then correclty outputs 
the sister terms as <em>jack</em> and <em>king</em>. See the example.</p>

<p>Example:</p>

<pre><code>wn.fetchSynset("queen.n.7", function(err, synset){
    synset.getSisterTerms(function(err, data){ console.log(util.inspect(data, null, 5)); });
})
</code></pre>

<p>Output:</p>

<pre><code>[ { synsetid: 103318973,
    words: 
     [ { lemma: 'court card' },
       { lemma: 'face card' },
       { lemma: 'picture card' } ],
    definition: 'one of the twelve cards in a deck bearing a picture of a face',
    pos: 'n',
    lexdomain: 'noun.artifact',
    hyponym: 
     [ { synsetid: 103594280,
         pos: 'n',
         lexdomain: 'noun.artifact',
         definition: 'one of four face cards in a deck bearing a picture of a young prince',
         words: [ { lemma: 'jack' }, { lemma: 'knave' } ] },
       { synsetid: 103623428,
         pos: 'n',
         lexdomain: 'noun.artifact',
         definition: 'one of the four playing cards in a deck bearing the picture of a king',
         words: [ { lemma: 'king' } ] },
       { synsetid: 104039901,
         pos: 'n',
         lexdomain: 'noun.artifact',
         definition: 'one of four face cards in a deck bearing a picture of a queen',
         words: [ { lemma: 'queen' } ] } ] } ]
</code></pre>

<h4>
<a name="causeof" class="anchor" href="#causeof"><span class="octicon octicon-link"></span></a>.causeOf()</h4>

<h3>
<a name="other-functions" class="anchor" href="#other-functions"><span class="octicon octicon-link"></span></a>Other Functions</h3>

<h4>
<a name="wnprintinput" class="anchor" href="#wnprintinput"><span class="octicon octicon-link"></span></a>wn.print(input)</h4>

<p>This utility function takes as its input an object of any class from the module and prints the content in a nicely formatted
way to the terminal. An array of objects can also be supplied. </p>

<p>Example:</p>

<pre><code>wn.fetchSynset("fish.n.1").then(function(synsetArray){
    synsetArray.getHypernymsTree().each(function(hypernym){
            wn.print(hypernym);
        })
});
</code></pre>

<p>Output:</p>

<pre><code>S: (n) aquatic vertebrate (animal living wholly or chiefly in or on water)
    S: (n) craniate, vertebrate (animals having a bony or cartilaginous skeleton with a segmented spinal column and a large brain enclosed in a skull or cranium)
        S: (n) chordate (any animal of the phylum Chordata having a notochord or spinal column)
            S: (n) animal, animate being, beast, brute, creature, fauna (a living organism characterized by voluntary movement)
                S: (n) being, organism (a living thing that has (or can develop) the ability to act or function independently)
                    S: (n) animate thing, living thing (a living (or once living) entity)
                        S: (n) unit, whole (an assemblage of parts that is regarded as a single entity)
                            S: (n) object, physical object (a tangible and visible entity; an entity that can cast a shadow)
                                S: (n) physical entity (an entity that has physical existence)
                                    S: (n) entity (that which is perceived or known or inferred to have its own distinct existence (living or nonliving))
</code></pre>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/Planeshifter/node-wordnet-magic/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/Planeshifter/node-wordnet-magic/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/Planeshifter/node-wordnet-magic"></a> is maintained by <a href="https://github.com/Planeshifter">Planeshifter</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>